---
id: error-boundaries
title: Error Boundaries
permalink: docs/error-boundaries.html
---

В прошлом, ошибки JavaScript внутри компонентов портили внутреннуу состояние React и заставляли его [выдавать](https://github.com/facebook/react/issues/4026) [таинственные](https://github.com/facebook/react/issues/6895) [сообщения об ошибках](https://github.com/facebook/react/issues/8579) во время следующего рендера. Эти сообщения всегда вызывались ошибками, расположенными где-то выше в коде приложения, но React не предоставлял способа адекватно обрабатывать их в компонентах и не мог обработать их самостоятельно.


## Представляем Error Boundaries {#introducing-error-boundaries}

Ошибка JavaScript где-то в коде UI не должна рушить всё приложение. Чтобы реализовать это утверждение для пользователей React, React 16 водит концепцию "рубеж ошибок"("error boundary").

Error boundaries это компоненты React, которые **отлавливают ошибки JavaScript в любом месте дерева их дочерних компонентов, сохраняют их в журнал и выводят запасной UI** вместо рухнувшего дерева компонентов. Error boundaries ловят ошибки при рендеринге, в методах жизненного цикла и в конструкторах дерева компонентов, расположенного под ними.

> Замечание
>
> Error boundaries **не** поймают ошибки в:
>
> * Обработчиках событий ([подробнее](#how-about-event-handlers))
> * Асинхронном коде (напр. колбэки из `setTimeout` или `requestAnimationFrame`)
> * Серверсайд рендеринге
> * Самом компоненте error boundary (а не в его дочерних компонентах)

Классовый компонент является error boundary если он включает любой из двух (или оба) методов жизненного цикла [`static getDerivedStateFromError()`](/docs/react-component.html#static-getderivedstatefromerror) или [`componentDidCatch()`](/docs/react-component.html#componentdidcatch). Пользуйтесь `static getDerivedStateFromError()` при рендеринге запасного UI в случае отлова ошибки. Используйте `componentDidCatch()` при написании кода для журналирования информации об отловленной ощибке.

```js{7-10,12-15,18-21}
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновить состояние с тем, чтобы следующий рендер показал запасной UI.
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // Можно так же сохранить информацию об ошибке в соответствующую службу журнала ошибок
    logErrorToMyService(error, info);
  }

  render() {
    if (this.state.hasError) {
      // В качестве запасного можно отрендерить UI произвольного вида
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children; 
  }
}
```

И можно дальше им пользоваться, как обыконовенным компонентом:

```js
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

Error boundaries работают как `catch {}` блоки JavaScript, только для компонентов. Только классовые компоненты могут выступать в роли error boundaries. На практике, чаще всего целесообразным будет один раз описать компонент error boundary и использовать его по всему приложению.

Стоит обратить внимание, что **error boundaries отлавливают ошибки исключительно в своих дочерних компонентах**. Error boundary не сможет отловить ошибку внутри самого себя. Если error boundary не удается отрендерить сообщение об ощибке, то ошибка всплывает до ближайшего error boundary, расположенного над ним в дереве компонентов. В этом тоже ситуация напоминает то, как работают блоки `catch {}` в JavaScript.

## Работающая демонстрация {#live-demo}

См. [пример объявления и использования error boundary](https://codepen.io/gaearon/pen/wqvxGa?editors=0010) в [React 16](/blog/2017/09/26/react-v16.0.html).


## Где располагать Error Boundaries {#where-to-place-error-boundaries}

Гранулярность error boundaries оставляется на ваше усмотрение. Например вы можете охватить им навигационные (route) компоненты верхнего уровня, чтобы выводить пользователю сообщение "Что-то пошло не так", как часто делают при обработке ошибок серверные фреймворки. Также вы можете охватить error boundary отдельные виджеты, чтобы помешать им обрушить всё приложение.


## Новое поведение при обработке неотловленных ошибок {#new-behavior-for-uncaught-errors}

Это изменение влечёт за собой существенное последствие. **Начиная с React 16, ошибки, не отловленные ни одним из error boundary будут приводить к размонтированию всего дерева компонентов React.**

Хотя принятие этого решения и вызвало споры, согласно нашему опыту бОльшим злом будет вывести испорченный UI, чем удалить его целиком. К примеру в приложении типа Messenger, вывод поломанного UI может привести к тому, что пользователь отправит сообщение не тому адресату. Аналогично, будет хуже, если приложение для проведения платежей выведет пользователю неправильную сумму платежа, чем если оно не выведет вообще ничего.

Это изменение означает, что при мигрировании на React 16, вы с большой вероятностью натолкнётесь на незамеченные ранее ошибки в вашем приложении. Добавляя в ваше приложение error boundaries, вы получаете возможность обеспечивать более качественный пользовательский опыт (user experience) при возниновении ошибок.

Например, Facebook Messenger охватывает содержимое боковой и информационной панелей, журнала общения и поля ввода сообщений отдельными error boundary. Если один из этих компонентов UI упадёт, то остальные сохранят интерактивность.

Так же, мы очень рекомендуем пользоваться сервисами обработки ошибок JS (или написать ваш собственный аналогичный сервис) с тем, чтобы вы оказывались в курсе и могли устранять неотловленные исключения по мере их появления, ещё в продакшен—режиме.


## Stack Trace компонентов {#component-stack-traces}

В режиме разработки React 16 выводит на консоль сообщения обо всех ошибках, возникших при рендеринге, даже если приложения случайно их проглотило. Помимо сообщения об ошибке и стэка JavaScript, React 16 также выводит и stack trace компонентов. Теперь вы в точности можете видеть в каком именно месте дерева компонентов случилось страшное:

<img src="../images/docs/error-boundaries-stack-trace.png" style="max-width:100%" alt="Ошибка, отловленная компонентом Error Boundary">

Кроме этого, в stack trace компонентов выводятся имена файлов и номера строк. Такое поведение по умолчанию настроено в проектах, созданных при помощи [Create React App](https://github.com/facebookincubator/create-react-app):

<img src="../images/docs/error-boundaries-stack-trace-line-numbers.png" style="max-width:100%" alt="Ошибка, отловленная компонентом Error Boundary, включая номера строк">

Если вы не пользуетесь Create React App, вы можете вручную добавить к вашей конфигцурации Babel [вот этот плагин](https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source). Обратите внмание, что он предназначен исключительно для режима разработки и **должен быть деактивирован в продакшен**.

> Замечание
>
> Имена компонентов, выводимые в их stack trace определяются свойством [`Function.name`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name). Если ваше приложение поддерживает более старые браузеры и устройства, которые могут ещё не предоставлять его нативно (напр. IE 11), рассмотрите возможность включения полифилла `Function.name` в бандл вашего приложения, например [`function.name-polyfill`](https://github.com/JamesMGreene/Function.name). Альтернативно, вы можете явным образом задать значение пропа [`displayName`](/docs/react-component.html#displayname) в каждом из ваших компонентов.


## А как насчёт try/catch? {#how-about-trycatch}

`try` / `catch` - отличная конструкция, но она работает исключительно в императивном коде:

```js
try {
  showButton();
} catch (error) {
  // ...
}
```

В то время, как компоненты React являются декларативными, указывая *что* должно быть отрендерено:

```js
<Button />
```

Error boundaries сохраняют декларативную природу React и ведут себя так, как вы уже привыкли ожидать от компонентов React. Например, даже если ошибка, произошедшая в методе `componentDidUpdate`, будет вызвана `setState` где-то в глубине дерева компонентов, она всё равно корректно всплывёт к ближайшему error boundary.

## А что насчёт обработчиков событий? {#how-about-event-handlers}

Error boundaries **не** отлавливают ошибки, произошедшие в обработчиках событий.

React не нуждается в компонентах error boundary, чтобы корректно обработать ошибки в обработчиках событий. В отличие от метода `render` и методов жизненного цикла, обработчики событий не выполняются во время рендеринга. Таким образом, даже если они сгенерируют ошибку, React всё равно знает, что выводить на экран.

Чтобы отловить ошибку в обработчике событий, пользуйтесь обычной `try` / `catch` конструкцией JavaScript:

```js{9-13,17-20}
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    try {
      // Делаем что-то, что сгенерирует ошибку
    } catch (error) {
      this.setState({ error });
    }
  }

  render() {
    if (this.state.error) {
      return <h1>Отловил ошибку.</h1>
    }
    return <div onClick={this.handleClick}>Кликни меня</div>
  }
}
```

Обратите внимание, что приведённый выше пример демонстрирует обычное поведение JavaScript и не использует компонентов error boundary.

## Изменения в названиях по сравнению с React 15 {#naming-changes-from-react-15}

React 15 включал очень ограниченную поддержку error boundary с другим названием метода: `unstable_handleError`. Этот метод больше не работаеот и вам будет нужно заменить его в вашем коде на `componentDidCatch` начиная с первого бета—релиза React 16.

Для этого изменения мы написали [codemod](https://github.com/reactjs/react-codemod#error-boundaries), обеспечивающий автоматическую миграцию вашего кода.
